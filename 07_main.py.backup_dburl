"""
MindLab Health - Main FastAPI Application
==========================================
Complete mental health therapist matching platform API
"""

import os
import logging
from datetime import datetime, timedelta
from typing import Optional, List

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel, EmailStr

# Import models from our models module (models.py in same directory)
from models import Base, User, Appointment, Message, UserRole, AppointmentStatus

# Import auth functions from our auth module (auth.py in same directory)
from auth import (
    get_password_hash,
    verify_password,
    create_access_token,
    decode_access_token,
    get_current_user,
    validate_password_strength,
    validate_username
)

# Database configuration
DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://postgres:postgres@localhost:5432/mindlab_health"
)

engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create all tables
Base.metadata.create_all(bind=engine)

# FastAPI app initialization
app = FastAPI(
    title="MindLab Health API",
    description="Mental health therapist matching platform",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:8000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Middleware to handle HEAD requests
@app.middleware("http")
async def head_to_get_middleware(request, call_next):
    """
    Convert HEAD requests to GET requests and return empty body.
    This allows all GET routes to respond to HEAD requests properly.
    """
    if request.method == "HEAD":
        # Create a new request with GET method
        request._method = "GET"
        response = await call_next(request)
        # For HEAD requests, FastAPI should return headers only
        # The body is automatically stripped by Starlette
        return response
    return await call_next(request)


# Logging configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mindlab_health.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Mount static files (CSS, JS, images)
app.mount("/static", StaticFiles(directory="frontend"), name="static")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/token")

# Database dependency
def get_db():
    """Get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Pydantic schemas
class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str
    role: str = "patient"

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    role: str
    created_at: datetime
    
    class Config:
        from_attributes = True

class AppointmentCreate(BaseModel):
    therapist_id: int
    appointment_datetime: datetime
    notes: Optional[str] = None

class AppointmentResponse(BaseModel):
    id: int
    user_id: int
    therapist_id: int
    appointment_datetime: datetime
    status: str
    notes: Optional[str]
    
    class Config:
        from_attributes = True

class MessageCreate(BaseModel):
    recipient_id: int
    subject: str
    content: str

class MessageResponse(BaseModel):
    id: int
    sender_id: int
    recipient_id: int
    subject: str
    content: str
    read: bool
    timestamp: datetime
    
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str

# API Endpoints

@app.get("/", response_class=HTMLResponse)
async def root():
    """Serve the frontend index.html"""
    try:
        with open("frontend/index.html", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return "<h1>Frontend not found</h1><p>Please check that frontend files are in the correct location.</p>"


# HTML file routes (for dashboard, login, register, etc.)
@app.get("/dashboard.html", response_class=HTMLResponse)
async def serve_dashboard():
    """Serve the dashboard HTML page"""
    try:
        with open("frontend/dashboard.html", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Dashboard page not found")

@app.get("/login.html", response_class=HTMLResponse)
async def serve_login():
    """Serve the login HTML page"""
    try:
        with open("frontend/login.html", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Login page not found")

@app.get("/register.html", response_class=HTMLResponse)
async def serve_register():
    """Serve the register HTML page"""
    try:
        with open("frontend/register.html", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Register page not found")


@app.get("/api")
async def api_info():
    """API information endpoint"""
    return {
        "message": "Welcome to MindLab Health API",
        "version": "1.0.0",
        "docs": "/docs"
    }

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat()
    }

@app.post("/api/users/register", response_model=UserResponse)
async def register_user(user: UserCreate, db: Session = Depends(get_db)):
    """Register a new user"""
    logger.info(f"Registering new user: {user.username}")
    
    # Validate username
    if not validate_username(user.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid username format"
        )
    
    # Validate password strength
    is_valid, message = validate_password_strength(user.password)
    if not is_valid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=message
        )
    
    # Check if user exists
    existing_user = db.query(User).filter(
        (User.username == user.username) | (User.email == user.email)
    ).first()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username or email already registered"
        )
    
    # Create new user
    hashed_password = get_password_hash(user.password)
    db_user = User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_password,
        role=user.role
    )
    
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    logger.info(f"User registered successfully: {user.username}")
    return db_user

@app.post("/api/token", response_model=Token)
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """Login endpoint - OAuth2 password flow"""
    logger.info(f"Login attempt: {form_data.username}")
    
    # Find user
    user = db.query(User).filter(User.username == form_data.username).first()
    
    if not user or not verify_password(form_data.password, user.hashed_password):
        logger.warning(f"Failed login attempt: {form_data.username}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token
    access_token = create_access_token(
        data={"sub": user.username, "user_id": user.id}
    )
    
    logger.info(f"User logged in successfully: {form_data.username}")
    return {"access_token": access_token, "token_type": "bearer"}



# OAuth2 compatible endpoint (alias for /api/token)
@app.post("/token", response_model=Token)
async def login_oauth(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """OAuth2 compatible login endpoint - alias for /api/token"""
    return await login(form_data, db)

@app.get("/api/users/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current user information"""
    return current_user

@app.post("/api/appointments", response_model=AppointmentResponse)
async def create_appointment(
    appointment: AppointmentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new appointment"""
    logger.info(f"Creating appointment for user: {current_user.username}")
    
    # Verify therapist exists
    therapist = db.query(User).filter(
        User.id == appointment.therapist_id,
        User.role == "therapist"
    ).first()
    
    if not therapist:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Therapist not found"
        )
    
    # Create appointment
    db_appointment = Appointment(
        user_id=current_user.id,
        therapist_id=appointment.therapist_id,
        appointment_datetime=appointment.appointment_datetime,
        status="scheduled",
        notes=appointment.notes
    )
    
    db.add(db_appointment)
    db.commit()
    db.refresh(db_appointment)
    
    logger.info(f"Appointment created: {db_appointment.id}")
    return db_appointment

@app.get("/api/appointments/my", response_model=List[AppointmentResponse])
async def get_my_appointments(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user's appointments"""
    appointments = db.query(Appointment).filter(
        (Appointment.user_id == current_user.id) | 
        (Appointment.therapist_id == current_user.id)
    ).all()
    
    return appointments

@app.get("/api/appointments/{appointment_id}", response_model=AppointmentResponse)
async def get_appointment(
    appointment_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get specific appointment"""
    appointment = db.query(Appointment).filter(
        Appointment.id == appointment_id
    ).first()
    
    if not appointment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Appointment not found"
        )
    
    # Check authorization
    if appointment.user_id != current_user.id and appointment.therapist_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to view this appointment"
        )
    
    return appointment

@app.post("/api/messages", response_model=MessageResponse)
async def send_message(
    message: MessageCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Send a message"""
    logger.info(f"Sending message from {current_user.username}")
    
    # Verify recipient exists
    recipient = db.query(User).filter(User.id == message.recipient_id).first()
    if not recipient:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recipient not found"
        )
    
    # Create message
    db_message = Message(
        sender_id=current_user.id,
        recipient_id=message.recipient_id,
        subject=message.subject,
        content=message.content
    )
    
    db.add(db_message)
    db.commit()
    db.refresh(db_message)
    
    logger.info(f"Message sent: {db_message.id}")
    return db_message

@app.get("/api/messages/inbox", response_model=List[MessageResponse])
async def get_inbox(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get inbox messages"""
    messages = db.query(Message).filter(
        Message.recipient_id == current_user.id
    ).order_by(Message.timestamp.desc()).all()
    
    return messages

@app.get("/api/messages/sent", response_model=List[MessageResponse])
async def get_sent_messages(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get sent messages"""
    messages = db.query(Message).filter(
        Message.sender_id == current_user.id
    ).order_by(Message.timestamp.desc()).all()
    
    return messages

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
